"""An implementation of Fibonacci search."""
from searching.complexity import Complexity
from searching.types import Sequence, Number, OptionalNumber
from ..sequence_search_algorithm import SortedSequenceSearchAlgorithm
from .binary_search import BinarySearch


class ExponentialSearch(SortedSequenceSearchAlgorithm):
	"""An implementation of the Fibonacci search algorithm."""

	# the local instance of binary search for searching in exponential ranges
	binary_search = BinarySearch()

	@property
	def runtime_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(lg n)', avg='Θ(lg n)', best='Ω(1)')

	@property
	def space_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(lg n)', avg='Θ(lg n)', best=('Ω(1)'))

	def _upper_bound(self, numbers: Sequence, target: Number) -> OptionalNumber:
		"""
		Exponentially search for a range of numbers containing the target.

		Args:
			numbers: the sequence of SORTED numbers to find a range in
			target: the target number to look for

		Returns: the upper bound of the range of numbers containing target
		"""
		# initialize the upper bound to 1
		upper_bound = 1
		# while the bound is within the index and less than the target (i.e.
		# the target is _not_ contained in the bounds)
		while upper_bound < len(numbers) and numbers[upper_bound] < target:
			# grow the bounds exponentially
			upper_bound *= 2
		return upper_bound

	def __call__(self, numbers: Sequence, target: Number) -> OptionalNumber:
		"""
		Search for the target value in the sequence of numbers.

		Args:
			numbers: the sequence of numbers to search through
			target: the number to find in the sequence

		Returns: the index of the number if found, None otherwise

		Note: If sorting is disabled for this algorithm, the input numbers is
			  expected to be sorted.
		"""
		# sort the numbers
		numbers = self.sort(numbers)
		# make sure the target is within the bounds of the sorted array
		if not self.is_in_bounds(numbers, target):
			return None
		# get the upper bound
		upper_bound = self._upper_bound(numbers, target)
		if upper_bound is None:
			return None
		# use binary search to find the value within this bounds
		return self.binary_search._search(numbers, target, 0, upper_bound)

# explicitly define the public API of the module
__all__ = ['ExponentialSearch']
