"""An implementation of Fibonacci search."""
from numba import jit
from searching.complexity import Complexity
from searching.types import Sequence, Number, OptionalNumber
from ..sequence_search_algorithm import SortedSequenceSearchAlgorithm


@jit(nopython=True, cache=True)
def fibonaccis(n: float) -> list:
    """
    Return a sequence of fibonacci numbers upto a bound n.

    Args:
        n: the number to generate fibonacci numbers up to

    Returns: a fibonacci sequence bounded by an input n

    Note: this is an iterative implementation, not recursive
    """
    # start with three fibonaccis so the recursion can start cleanly. the
    # additional zero prevents the algorithm that uses this from ever having
    # a case where the length of this array is less than 3.
    fibs = [0, 0, 1]
    # while the greatest fibonacci number is less than n
    while fibs[-1] < n:
        # add another fibonacci number to the sequnce
        fibs.append(fibs[-2] + fibs[-1])
    return fibs


class FibonacciSearch(SortedSequenceSearchAlgorithm):
	"""An implementation of the Fibonacci search algorithm."""

	@property
	def runtime_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(lg n)', avg='Θ(lg n)', best='Ω(1)')

	@property
	def space_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(lg n)', avg='Θ(lg n)', best=('Ω(1)'))

	def _search(self, numbers: Sequence, target: Number) -> OptionalNumber:
		"""
		Search for the target in numbers recursively.

		Args:
			numbers: the sequence of numbers to search through
			target: the target to find in numbers

		Returns: the index of target in numbers if found, None otherwise
		"""
		# generate a fibonacci sequence that contains the length of the array
		# i.e. the largest fibonacci number in the sequence is greater than
		# or equal to the length of numbers
		fibs = fibonaccis(len(numbers))
		# get the m-2 fibonacci number (3rd from the last) as the index
		index = fibs[-3]
		# base case, check if this index points to the target
		if numbers[index] == target:
			return index
		# check which side of the list to recurse on
		elif numbers[index] < target:
			# this is the right side of the array, so the index needs added
			return self._search(numbers[index:], target) + index
		else:
			# the left side will start from 0 anyway, no addition needed here
			return self._search(numbers[:index], target)

	def __call__(self, numbers: Sequence, target: Number) -> OptionalNumber:
		"""
		Search for the target value in the sequence of numbers.

		Args:
			numbers: the sequence of numbers to search through
			target: the number to find in the sequence

		Returns: the index of the number if found, None otherwise

		Note: If sorting is disabled for this algorithm, the input numbers is
			  expected to be sorted.
		"""
		# sort the numbers
		numbers = self.sort(numbers)
		# make sure the target is within the bounds of the sorted array
		if not self.is_in_bounds(numbers, target):
			return None
		# start the recursion tree
		return self._search(numbers, target)


# explicitly define the public API of the module
__all__ = ['FibonacciSearch']
