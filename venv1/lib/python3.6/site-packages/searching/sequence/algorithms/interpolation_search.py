"""An implementation of interpolation search."""
from searching.complexity import Complexity
from searching.types import Sequence, Number, OptionalNumber
from ..sequence_search_algorithm import SortedSequenceSearchAlgorithm


class InterpolationSearch(SortedSequenceSearchAlgorithm):
	"""An implementation of the interpolation search algorithm."""

	@property
	def runtime_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(n)', avg='Θ(lg lg n)', best='Ω(1)')

	@property
	def space_complexity(self) -> Complexity:
		"""Return the runtime complexity for the algorithm."""
		return Complexity(worst='O(lg n)', avg='Θ(lg n)', best=('Ω(1)'))

	def _predict_position(self, numbers: Sequence, target: Number,
						  left: int, right: int) -> int:
		"""
		Return the anticipated index of the target in the given bounds.

		Args:
			numbers: the sequence of numbers to search through
			target: the number to find in the sequence
			left: the left bounding index of the sequence
			right: the right bounding index of the sequence

		Returns: the predicted index of target in numbers[left:right]

		Note: this method assumes a _uniform_ distribution
		"""
		# calculate the numerator of the expression
		numerator = (target - numbers[left]) * (right - left)
		# calculate the denominator of the expression
		denominator = numbers[right] - numbers[left]
		# check for a divide by zero error
		if denominator == 0:
			# check if this range of equal numbers is the target
			if numbers[left] == target:
				return left
			# target cant exist in this range, return out of range
			return -1
		# divide the numerator by the denominator and add `left`
		return int((numerator / denominator) + left)

	def _search(self, numbers: Sequence, target: Number,
				left: int, right: int) -> OptionalNumber:
		"""
		Search for the target recursively in the list of numbers.

		Args:
			numbers: the array of SORTED numbers to search in
			target: the number to find in the array
			left: the left bound index of the array
			right: the right bound index of the array

		Returns: the index of the target in numbers
		"""
		# check the base case
		if right < left:
			return None
		# use the predictive formula to calculate a "midpoint"
		midpoint = self._predict_position(numbers, target, left, right)
		# check if the model predicts the midpoint outside the index
		if midpoint < 0 or midpoint >= len(numbers):
			return None
		# check if we found the target
		if numbers[midpoint] == target:
			return midpoint
		# check which side of the list to recurse on
		elif numbers[midpoint] < target:
			return self._search(numbers, target, midpoint + 1, right)
		else:
			return self._search(numbers, target, left, midpoint - 1)

	def __call__(self, numbers: Sequence, target: Number) -> OptionalNumber:
		"""
		Search for the target value in the sequence of numbers.

		Args:
			numbers: the sequence of numbers to search through
			target: the number to find in the sequence

		Returns: the index of the number if found, None otherwise

		Note: If sorting is disabled for this algorithm, the input numbers is
			  expected to be sorted.
		"""
		# sort the numbers
		numbers = self.sort(numbers)
		# make sure the target is within the bounds of the sorted array
		if not self.is_in_bounds(numbers, target):
			return None
		# start the recursion tree on the numbers with the left set to the
		# starting left index (0) and the right set to the far right
		# index (length - 1).
		return self._search(numbers, target, 0, len(numbers) - 1)


# explicitly define the public API of the module
__all__ = ['InterpolationSearch']
